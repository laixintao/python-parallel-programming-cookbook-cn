进程如何同步
============

多个进程可以协同工作来完成一项任务。通常需要共享数据。所以在多进程之间保持数据的一致性就很重要了。需要共享数据协同的进程必须以适当的策略来读写数据。相关的同步原语和线程的库很类似。

进程的同步原语如下：

- **Lock**: 这个对象可以有两种装填：锁住的（locked）和没锁住的（unlocked）。一个Lock对象有两个方法， ``acquire()`` 和 ``release()`` ，来控制共享数据的读写权限。
- **Event**: 实现了进程间的简单通讯，一个进程发事件的信号，另一个进程等待事件的信号。 ``Event`` 对象有两个方法， ``set()`` 和 ``clear()`` ，来管理自己内部的变量。
- **Condition**: 此对象用来同步部分工作流程，在并行的进程中，有两个基本的方法： ``wait()`` 用来等待进程， ``notify_all()`` 用来通知所有等待此条件的进程。
- **Semaphore**: 用来共享资源，例如，支持固定数量的共享连接。
- **Rlock**: 递归锁对象。其用途和方法同 ``Threading`` 模块一样。
- **Barrier**: 将程序分成几个阶段，适用于有些进程必须在某些特定进程之后执行。处于障碍（Barrier）之后的代码不能同处于障碍之前的代码并行。  

|how|
-----

下面的代码展示了如何使用 ``barrier()`` 函数来同步两个进程。我们有4个进程，进程1和进程2由barrier语句管理，进程3和进程4没有同步策略。


